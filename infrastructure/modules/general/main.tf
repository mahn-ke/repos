terraform {
  required_providers {
    github = {
      source  = "integrations/github"
      version = "~> 6.6.0"
    }
  }
}

variable "GITHUB_WORKFLOWS" {
  description = "GitHub App integration ID for required status checks"
  type        = number
  default     = 15368
}

resource "github_repository_ruleset" "pull_requests_on_default" {
  name        = "main"
  repository  = github_repository.repos.name
  target      = "branch"
  enforcement = "active"

  bypass_actors {
    actor_id    = 0
    actor_type  = "OrganizationAdmin"
    bypass_mode = "always"
  }
  bypass_actors {
    actor_id    = 5
    actor_type  = "RepositoryRole"
    bypass_mode = "always"
  }

  conditions {
    ref_name {
      include = ["~DEFAULT_BRANCH"]
      exclude = []
    }
  }

  rules {
    required_linear_history = true

    required_status_checks {
      strict_required_status_checks_policy = true
      required_check {
        context        = "deploy / build"
        integration_id = var.GITHUB_WORKFLOWS
      }
      required_check {
        context        = "deploy / infrastructure-terraform-plan"
        integration_id = var.GITHUB_WORKFLOWS
      }
      required_check {
        context        = "deploy / service-terraform-plan"
        integration_id = var.GITHUB_WORKFLOWS
      }
      required_check {
        context        = "deploy / prepare-postgres"
        integration_id = var.GITHUB_WORKFLOWS
      }
    }
  }
}

resource "github_repository" "repos" {
  name                        = var.repository_reference
  visibility                  = "public"
  auto_init                   = false
  license_template            = "gpl-3.0"
  allow_auto_merge            = true
  delete_branch_on_merge      = true
  allow_merge_commit          = false
  allow_rebase_merge          = true
  allow_squash_merge          = true
  has_downloads               = false
  has_issues                  = true
  has_projects                = false
  has_wiki                    = false
  squash_merge_commit_title   = "PR_TITLE"
  squash_merge_commit_message = "PR_BODY"
  vulnerability_alerts        = true
}

output "repository_name" {
  value = github_repository.repos.name
}

resource "github_issue_labels" "repo_labels" {
  repository = github_repository.repos.name

  label {
    name        = "automerge"
    description = "Pull Request that GitHub Actions automatically integrates, once all checks have passed"
    color       = "FFFFFF"
  }
}



resource "github_repository_environment" "production" {
  repository          = github_repository.repos.name
  environment         = "production"
  prevent_self_review = false
  reviewers {
    users = [var.user_vimaster]
  }
}

variable "auto_generated_header" {
  description = "Header indicating the file is auto-generated"
  type        = string
  default     = <<EOT
############################################################
## DO NOT CHANGE - THIS IS AUTOGENERATED BY mahn-ke/repos ##
############################################################
EOT
}

resource "github_repository_file" "renovate" {
  repository          = github_repository.repos.name
  file                = "renovate.json"
  content             = "${replace(var.auto_generated_header, "#", "/")}\n${file("${path.module}/src/renovate.json5")}"
  commit_message      = "Managed by Terraform${strcontains(github_repository.repos.name, "repos") ? " [no ci]" : ""}"
  overwrite_on_create = true
}

resource "github_repository_file" "workflow_automerge" {
  repository          = github_repository.repos.name
  file                = ".github/workflows/autogenerated-automerge.yml"
  content             = "${var.auto_generated_header}\n${file("${path.module}/src/.github/workflows/automerge.yml")}"
  commit_message      = "Managed by Terraform${strcontains(github_repository.repos.name, "repos") ? " [no ci]" : ""}"
  overwrite_on_create = true
}

resource "github_repository_file" "workflow_deploy" {
  repository          = github_repository.repos.name
  file                = ".github/workflows/autogenerated-deploy.yml"
  content             = "${var.auto_generated_header}\n${file("${path.module}/src/.github/workflows/deploy.yml")}"
  commit_message      = "Managed by Terraform${strcontains(github_repository.repos.name, "repos") ? " [no ci]" : ""}"
  overwrite_on_create = true
}

resource "github_repository_file" "workflow_backup" {
  repository          = github_repository.repos.name
  file                = ".github/workflows/autogenerated-backup.yml"
  content             = "${var.auto_generated_header}\n${file("${path.module}/src/.github/workflows/backup.yml")}"
  commit_message      = "Managed by Terraform${strcontains(github_repository.repos.name, "repos") ? " [no ci]" : ""}"
  overwrite_on_create = true
}

resource "github_repository_file" "infrastructure-main-tf" {
  repository          = github_repository.repos.name
  file                = "infrastructure/autogenerated-main.tf"
  content             = "${var.auto_generated_header}\n${replace(file("${path.module}/infrastructure/main.tf"), "$REPOSITORY", github_repository.repos.name)}"
  commit_message      = "Managed by Terraform${strcontains(github_repository.repos.name, "repos") ? " [no ci]" : ""}"
  overwrite_on_create = true
}

resource "github_repository_file" "infrastructure-gitignore" {
  repository          = github_repository.repos.name
  file                = "infrastructure/.gitignore"
  content             = "${var.auto_generated_header}\n${file("${path.module}/infrastructure/.gitignore")}"
  commit_message      = "Managed by Terraform${strcontains(github_repository.repos.name, "repos") ? " [no ci]" : ""}"
  overwrite_on_create = true
}

resource "github_repository_file" "service-main-tf" {
  repository          = github_repository.repos.name
  file                = "service/autogenerated-main.tf"
  content             = "${var.auto_generated_header}\n${replace(file("${path.module}/service/main.tf"), "$REPOSITORY", github_repository.repos.name)}"
  commit_message      = "Managed by Terraform${strcontains(github_repository.repos.name, "repos") ? " [no ci]" : ""}"
  overwrite_on_create = true
}

resource "github_repository_file" "service-gitignore" {
  repository          = github_repository.repos.name
  file                = "service/.gitignore"
  content             = "${var.auto_generated_header}\n${file("${path.module}/service/.gitignore")}"
  commit_message      = "Managed by Terraform${strcontains(github_repository.repos.name, "repos") ? " [no ci]" : ""}"
  overwrite_on_create = true
}
